DB(데이터베이스) -data base

##### [1.DBMS(DataBase Management System) - 20.01.31 KDH](#DBMS)

##### [2. 데이터베이스 풀 - 20.01.31 KSW](#데이터베이스 풀)

##### [3. 정규화(1NF, 2NF, 3NF, BCNF) - 20.01.31 KSW](#정규화(1NF, 2NF, 3NF, BCNF))

---

## DBMS

<img src="/assets/DBMS_structure.png">

#### 용어정리

* **데이터 (data)** : 의미를 가지며 기록될 수 있는 사실
* **데이터베이스 (database)** : 서로 연관이 있는 데이터의 모임
* **작은 세계(mini-world)** : 전체 세계의 일부분으로 데이터베이스 구축의 대상
* **데이터베이스 관리 시스템(DBMS)** : 데이터베이스를 생성하고, 데이터를 저장 및 관리할 수 있도록 하는 기능을 제공하는 전문 프로그램
* **데이터베이스 시스템 (database system)** : DBMS + DB
* **개체(object)** : 어떠한 사물들을 대표하는 것 (**학생** - 짱구, 철수 등등 /**수업** - DB, OS 등등 )
* **메타데이터(meta - data)** : 기본 데이터베이스의 구성, 데이터 항목 타입, 저장 구조, 제약조건을 명시하는 데이터
* **시스템 카탈로그 (system catalog)** : 메타 데이터를 저장 및 관리하는 장소
* **뷰(view)** : 전체 DB로부터 추출된 가상의 데이터 베이스



#### DB의 특징

* **데이터베이스 시스템의 자기 기술성** : DB내에서 데이터 자체 뿐만 아니라 DB 특성에 관한 데이터를 시스템에서 관리
* **프로그램과 데이터의 격리** : 데이터와 프로그램이 각각 따로 존재하여 데이터가 변경되어도 프로그램에 영향을 주지 않음
* **데이터 추상화** : 구조에 관한 상세 정보를 감춤(사용자에게 view만 제공함)
* **데이터에 대한 다중 뷰 제공** : 사용자의 관점에 따라서 다른 형태의 뷰를 제공
* **데이터 공유** : 다수의 사용자가 동시 접근 가능, 동시성 제어(concurrency control) 기능



#### DB사용자 분류 

* **시스템 분석가** : 사용자의 요구사항 분석, 이에 만족하는 트랜잭션 명세 설계
* **DB 설계자** : DB에 저장된 데이터를 선정, DB의 구조 및 특성을 정의
* **응용 프로그래머** : 트랜잭션 명세를 참고하여 응용 프로그램 작성
* **DB관리자 (DBA)** : DB 시스템과 관련된 자원 관리
* **최종 사용자** : DB에 대하여 질의, 변경, 보고서 등을 작성하는 사람
* **DBMS 설계 및 구현자** : DBMS 모듈들과 인터 페이스들을 소프트웨어 패키지로 설계하고 구현
* **도구 개발자** : 데이터베이스 설꼐, 사용, 성능 개선등에 필요한 소프트웨어 설계 및 구현
* **운영 및 유지 보수자** : DB시스템을 위한 하드웨어 및 소프트웨어 환경의 운영 및 유지 보수



#### DBMS의 기능

* 데이터 중복의 제어
  * 데이터 중복 : 동일한 데이터가 여러 곳에서 저장 및 관리
    * 문제점 : 디스크의 낭비, 데이터 일관성(consistency)의 결여 유발
  * 여러 사용자가 하나의 DB를 공유하도록 하여 이러한 중복의 문제 해결
* 권한없는 접근의 통제
  * 접근이 허용된 사용자만 데이터에 접근 가능, 권한 관리 가능
* 프로그램 데이터의 지속성 제공
  * 프로그램과 데이터는 독립적이므로 프로그램에 상관없이 데이터 보존
* 다양한 사용자 인터페이스 제공
  * 사용자에 따라 적합한 형테의 DB접근 방법 제공 (질의어, 프로그래밍 인터페이스 등)
* 관계 표현 기능
  * 서로 다른 데이터간에 다양한 형태의 연관성을 표현할 수 있는 기능 제공
* **무결성 제약 조건의 시행**
  * 무결성 : 응용 데이터가 지정된 제약 조건을 만족해야 하는 성질
  * 무결성에 관한 제약 조건을 정의, 정의된 무결성 제약 조건을 검사
* 백업 및 회복
  * 하드웨어 및 소프트웨어이 고장으로부터 복구 가능
  * 백업 : DB내의 데이터를 중복 저장하는 기능
  * 회복 : 고장시 백업된 데이터로부터 최신 데이터 복구하는 기능



#### DB사용 효과

* **표준화에 공헌** : 조직 내 모든 부서가 표준화 하여 데이터 관리
* **응용 프로그램 개발 시간 단축** : DBMS를 이용해서 처리가 가능하므로 개발 부담 줄음.
* **데이터베이스 구조 수정에 융통성제공** : DB내 자료 구조가 변경되어도 사용자에 영향 X
* **항상 최신의 정보 제공** : 다른 사람의 변경사항을 즉시 참조
* **규모의 경제성** : 조직내 데이터 통합관리로 업무의 중복성이 줄음.



##### DBMS를 사용시 단점

1. 초기 투자비용이 높음.
2. 보안, 동시성 제어, 회복, 무결성 조건 등의 오버헤드가 큼.
3. 단순 작업 시에는 굳이 필요 X.
4. 실시간 데이터 처리 요구 사항이 엄격한 경우 적절하지 않음.
5. 단일 사용자 사용 시 적절하지 않음.



#### 데이터 모델의 개념

* 데이터 추상화를 제공하기 위한 도구
* DB의 구조를 명시하는데 사용되는 개념들의 집합
* 제공하는 개념들의 유형에 따라 모델 분류 가능



#### 데이터 모델의 분류

* 물리적 데이터 모델
  * 데이터가 컴퓨터 내에서 물리적으로 어떻게 저장되는가에 관한 세부 사항을 명시
  * 실질적 데이터 저장 방식과 low-level의 데이터 모델
  * 레코드 형식, 순서, 접근 경로 등의 정보 제공
* 개념적 데이터 모델
  * 데이터를 개념적으로 표현하는 방식
  * 일반 사용자들이 인식하는 방식과 밀접한 상위 수준의 데이터 모델
  * 대표적인 예시 ER모델
* 표현 데이터 모델
  * 물리적 데이터 모델과 개념적 데이터 모델의 중간 수준
  * 일반 사용자들이 이해할 수 있는 방식으로 데이터를 표현하면서도 실질적 데이터 저장방식과도 잘 대응되는 방식 제공
  * 대부분의 DBMS에서 채택
  * 예시 : 관계 모델, 네트워크 모델, 계층 모델



#### 스키마와 인스턴스

* 스키마 

  * 데이터 베이스 구조에 대한 명세
  * 설계과정에서 정의
  * 자주 변경 X
  * 구성
    * 내부단계 : 물리적 저장 구조를 기술하는 내부 스키마
    * 개념단계 : 전체 DB의 논리적 구조를 기술하는 개념 스키마
    * 외부단계 (view단계) : 사용자에 따라서 특정 부분만 기술하는 외부 스키마(뷰) 

  <br>

* 인스턴스

  * 특정 시점의 DB 내용. 데이터 그 자체로 이해하면 편함.
  * 새로운 데이터의 삽입, 갱신, 삭제에 따라 지속적 변경.



#### 데이터 독립성

* 하위 단계의 스키마를 변경하여도 상위 단계의 스키마에 영향 X
* 논리적 데이터 독립성 : 개념 스키마가 변경되어도 외부 스키마가 영향 X
* 물리적 데이터 독립성 : 내부 스키마가 변경되어도 개념 스키마가 영향 X



#### DBMS 분류

* 데이터 모델에 의한 분류
  * 관계모델 : 레코드들의 집합을 포함하는 다수의 테이블로 표현
  * 네트워크 모델 : 레코드 타입과 1:N 관계의 집합 타입
  * 계층 모델 : 계층적 트리 구조를 이용하여 표현
  * 객체지향 모델 : 객체들의 집합을 포함하는 다수의 클래스로 표현
* 사용자 수에 의한 분류
  * 단일 사용자용
  * 다수 사용자용
* 분산 사이트 수에 의한 분류
  * 중앙 집중형 DBMS
  * 분산 DBMS
* 용도에 의한 분류
  * 범용 DBMS
  * 특수 목적용 DBMS

---



## 데이터베이스 풀

#### Connection Pool

DB와 미리 connection( 연결 )을 해놓은 객체들을 pool( 웅덩이 )에 저장해두었다가,

클라이언트 요청이 오면 커넥션을 빌려주고, 볼일이 끝나면 다시 커넥션을 반납받아 pool에 저장하는 방식

<img src="/assets/connectionpool.png">

클라이언트가 DB와 연결이 필요할 때, connection pool에서 connection을 빌려와 DB에 접근해서 쿼리를 막 날린 후, 볼 일이 끝나면 사용했던 connection을 다시 pool에 반납을 하는 과정

<br>

#### Connction이 부족하면?

- 모든 요청이 DB에 접근하고 있고 남은 Conncetion이 없다면, 해당 클라이언트는 대기 상태로 전환시키고 Pool에 Connection이 반환되면 대기 상태에 있는 클라이언트에게 순차적으로 제공된다.

#### 왜 사용할까?

- 매 연결마다 Connection 객체를 생성하고 소멸시키는 비용을 줄일 수 있다.
- 미리 생성된 Connection 객체를 사용하기 때문에, DB 접근 시간이 단축된다.

<br>

​	=> 미리 연결을 맺고 있는 커넥션들이 있기 때문에 커넥션을 맺고 끊는 과정이 불필요.

​		 즉, DB 접근 시 **불필요한 작업( 커넥션 생성, 끊기 )이 사라지므로 성능향상을 기대**

<br>

- DB에 접근하는 Connection의 수를 제한하여, 메모리와 DB에 걸리는 부하를 조정할 수 있다.

  => 커넥션 또한 객체이므로 **메모리를 차지**

  ​	 따라서 무작정 많이 늘리는 것은 메모리를 많이 차지하게 되므로 오히려 성능이 떨어지는 결과 초래

<br>

#### Thread Pool

- 비슷한 맥락으로 Thread pool이라는 개념도 있다.
- 이 역시 매 요청마다 요청을 처리할 Thread를 만드는것이 아닌, 미리 생성한 pool 내의 Thread를 소멸시키지 않고 재사용하여 효율적으로 자원을 활용하는 기법.

#### Thread Pool과 Connection pool

- WAS(Web Application Server)에서 Thread pool과 Connection pool내의 Thread와 Connection의 수는 직접적으로 메모리와 관련이 있기 때문에, 많이 사용하면 할 수록 메모리를 많이 점유하게 된다. 그렇다고 반대로 메모리를 위해 적게 지정한다면, 서버에서는 많은 요청을 처리하지 못하고 대기 할 수 밖에 없다.
- 보통 WAS의 Thread의 수가 Conncetion의 수보다 많은 것이 좋은데, 그 이유는 모든 요청이 DB에 접근하는 작업이 아니기 때문이다.

<br>

## 정규화(1NF, 2NF, 3NF, BCNF)

#### 정규화

*관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를* *정규화라고 한다.*



함수적 종속성을 이용해서 연관성 있는 속성들을 분류하고, 각 릴레이션들에서 이상현상이 생기지 않도록 하는 과정을 말한다.

정규화 된 정도를 정규형(Normal Form) 으로 표현하는데, 정규형에는 1NF, 2NF, 3NF, BCNF, 4NF, 5NF, 6NF 까지 있다. 비공식적 표현으로는 3NF 가 되었으면 정규화 되었다고 말한다. 3NF 테이블의 대부분이 삽입, 변경, 삭제 이상이 없으며, 3NF 테이블의 대부분이 BCNF, 4NF, 5NF이다.

각 정규형이 되기 위해서는 만족시켜야 할 제약조건들이 있다. 높은 차수의 정규형으로 갈 수록 조건이 까다롭다.

<br>

#### 제 1 정규형 (1NF; First Normal Form)

*릴레이션에 속한 모든 속성의 도메인이 원자 값으로만 구성되어 있으면 **제1정규형**에 속한다.*

<br>

| **STUDENT_ID** |          **COURSE_ID**          |   GRADE   | STUDENT_NM |
| :------------: | :-----------------------------: | :-------: | :--------: |
|    20800399    | CSE011101, CSE022202, CSE033303 | A+, A, B+ |    야붕    |

위와같은 형태의 릴레이션은 제1정규형을 만족하지 않는다. 최소한 아래와 같은 형태가 되어야 제1정규형을 만족한다고 할 수 있다.

<br>

관계형 데이터베이스의 릴레이션은 모든 속성이 원자 값을 가지는 특성이 있기 때문에, 최소한 제1정규형을 만족해야 릴레이션이 될 자격이 있다.

| **STUDENT_ID** | **COURSE_ID** | GRADE | STUDENT_NM |
| :------------: | :-----------: | :---: | :--------: |
|    20800399    |   CSE011101   |  A+   |    야붕    |
|    20800399    |   CSE022202   |   A   |    야붕    |
|    20800399    |   CSE033303   |  B+   |    야붕    |

<br>

#### 제 2 정규형 (2NF; Second Normal Form)

제1정규형만 만족시키는 릴레이션에서 부분 함수 종속성을 가지게 되는 경우 삽입이상, 갱신이상, 삭제이상 세가지 이상현상이 모두 나타나게 된다.

*제1정규형에 속하면서, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 **제2정규형**이다.*

<br>

